---
layout: post
title: 算法基础
date: 2021-11-20
author: 笨比sy
tags: [C++, Newbie]
comments: false
toc: true
pinned: false
layout: post
---

思想。

<!-- more -->

# 算法基础

## 1.前缀和与差分

### 1.1前缀和

数组中某个下标之前所有数组元素的总和，$S[i]=∑a[j] , j∈[1,i] $

使用前缀和的话，只需要一次O(n)的预处理，此后每次询问的时 间复杂度均为$O(1)$，即$s[r]-s[l-1]$

#### 一维前缀和

```c++
const int N=1e5+10;
int sum[N],a[N];//sum[N]=a[1]+a[2]+...+a[N]
for(int i=1;i<=n;i++)
	sum[i]=sum[i-1]+a[i];
printf("%d\n",sum[r]-sum[l-1]);//输出从l到r的数组和
```

#### 二维前缀和

```c++
for(int i=1;i<=n;i++)for(int j=1;j<=mm;j++)
{
    s[i][j]=s[i-1][j]+s[i][j-1]+A[i][j]-s[i-1][j-1];//对A数组创建前缀和数组s，进行读入计算
}
int x1,x2,y1,y2;
scanf("%d%d%d%d",&x1,&y1,&x2,&y2);//输入求和区域的坐左上与右下的坐标
int sumA=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1];//前缀和运算输出运算
printf("%d",sumA);
```

### 1.2差分

前缀和的逆运算捏，a是b数组的前缀和数组，b就是a数组的差分数组w

但其实这里的b就是前缀和中要输入的“原数组”，既$b[n] = a[n] - a[n-1];$

用法：对原一维数组，将序列中[l, r]之间的每个数加上c

#### 一维差分

```c++
for(int i=1;i<=n;i++)
{
    scanf("%d",&a[i]);
    b[i]=a[i]-a[i-1];//在输入a数组的同时构建其差分数组b
}
b[l]+=c;
b[r+1]-=c;//对b数组进行改动
for(int i=1;i<=n;i++)
{
    b[i]+=b[i-1];//对b进行一个前缀和的求，a→b→a'过程
    printf("%d",b[i]);//同时输出啦，没必要再开一个数组去储存的
}
```

**⚠这里并没有必要再开一个数组存储数据呢，在循环之中直接输出就可以了**

#### 二维差分

```c++
void insert(int x1,int y1,int x2,int y2,int c)
{ 
    b[x1][y1]+=c; 
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c; 
    b[x2+1][y2+1]+=c; 
    return ;
}//这里的b数组是差分数组！1.构建；2.处理
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
    insert(i,j,i,j,a[i][j]);//对a构建b插分数组（通过函数
insert(x1,y1,x2,y2,c);
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
    b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
	//printf("%d",b[i]);
		//构建a'，a'=b，当然你也可以像上面一样同时输出
```

## 2.排序

### 2.1选择排序

1. 我们要把最小的数放在第一个位置，把第二小的数放在第二个位置...

所以我们要依次遍历这些位置

2. 我们要在剩下的位置，找到最小的数，并把它的**位置**记录下来。

3. 把 最小的数 与 当前要放的位置上的数 交换。

```c++
for(int i = 1; i <= n; i++) 
{ //遍历要放的数的位置 
    int pos = i;//记录最小的数的位置,默认为第i个 
    for(int j = i + 1; j <= n; i++) 
    {//在剩下的数中寻找最小的数 
        if(a[j] < a[pos]) //记录位置 pos = j; 
    }swap(a[pos], a[i]); 
}
```

注意在这种方式中，代码实现的是记录最小数的**位置序号**，而不是将最小数和次小数的位置进行交换。

复杂度为$O(n^2)$

### 2.2插入排序

​	1.依次遍历每一个数,表示当前要插入的数

​	2.依次与前面排序的数比较,如果满足条件,则交换位置,如果不满足,则停止,进行下一次插入

​	3.依次进行上述操作,直到遍历完所有数组。

```c++
for(int i = 2; i <= n; i++)
{ //遍历要插入的数 
    for(int j = i; j >= 2; j--)
    { //依次与前面要比较的数比较 
        if(a[j] < a[j - 1]) 
            swap(a[j], a[j - 1]);
        else
            break;//如果不符合的话就停止
    } 
}
```

复杂度为$O(n^2)$

### 2.3归并排序

```c++
int a[n], c[n];//a是要排序的数组 
void msort(int l, int r) //l,r是排序的区间 
{ 
    if(l == r) return ; 
    int mid = (l + r) >> 1;
    msort(l, mid); 
    msort(mid + 1, r); //当上面程序执行完之后,就意味着两个子区间已经排序完成了 //在这里进行一波排序
}

void mSort(int l, int r) 
{ 
    if(l == r) return ; 
    int mid = (l + r) >> 1, k = l, i = l, j = mid + 1; 
    mSort(l, mid); mSort(mid + 1, r); 
    while(i <= mid && j <= r) 
    { 
        if(a[i] <= a[j]) c[k++] = a[i++];
        else c[k++] = a[j++]; 
    }
    while(i <= mid) 
        c[k++] = a[i++];
    while(j <= r) 
        c[k++] = a[j++]; 
    for(int s = l; s <= r; ++s) 
        a[s] = c[s];
}
```

时间复杂度*O*(*nlog*(*n*))

### 2.4快速排序

```c++
sort(a+1,a+1+n);
```

前面是要排序的数的第一个位置,后面是最后一个位置**再加上一**

默认是从小到大排序。

时间复杂度*O*(*nlog*(*n*))

这就需要用到自定义排序函数了

```c++
bool cmp(int x, int y) //名字随便取,字符型自定，必须是bool

{ 

	return x > y; //if x>y，从大到小排

}

sort(a + 1, a + 1 + n, cmp);
```

这么做时,可以理解为用*cmp*这个函数**替代**它默认的比较函数。

当比较函数返回*true*时,排序函数就会进行交换,所以我们修改这个排序函数,就能够自定义排序规则了。

#### 	结构体排序

​		在排序函数中加入struct就好

### 2.5桶排序

假设有*n*个数,它的值域是[0, *m*]，那我我们造*m*个桶,把每个数放到和它数值对应的**桶**中。全部放完之后,我们再**从小到大**把每个桶中的数倒出来,排成一排。

并且受限于数据值域。

```c++
int a[maxN], b[maxM];//a为要排序的数组,b为桶 
for(int i = 1; i <= n; ++i) 
	b[a[i]]++; 
for(int i = 1; i <= m; ++i) 
	if(b[i]) 
	{ 
		for(int j = 1; j <= b[i]; ++j) 
			printf("%d ", i); 
	}
```

空间复杂度和时间复杂度都是*O*(*m*)



先找到二分法的上下限

